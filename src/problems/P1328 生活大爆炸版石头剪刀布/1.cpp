/*

题目描述
石头剪刀布是常见的猜拳游戏:石头胜剪刀,剪刀胜布,布胜石头。如果两个人出拳一 样，则不分胜负。在《生活大爆炸》第二季第8集中出现了一种石头剪刀布的升级版游戏。

升级版游戏在传统的石头剪刀布游戏的基础上,增加了两个新手势:

斯波克:《星际迷航》主角之一。

蜥蜴人:《星际迷航》中的反面角色。

这五种手势的胜负关系如表一所示,表中列出的是甲对乙的游戏结果。



现在,小 A和小 B尝试玩这种升级版的猜拳游戏。已知他们的出拳都是有周期性规律的，但周期长度不一定相等。例如：如果小A以“石头-布-石头-剪刀-蜥蜴人-斯波克”长度为 66 的周期出拳,那么他的出拳序列就是“石头-布-石头-剪刀-蜥蜴人-斯波克-石头-布-石头-剪刀-蜥蜴人-斯波克-......”,而如果小B以“剪刀-石头-布-斯波克-蜥蜴人”长度为 55 的周期出拳,那么他出拳的序列就是“剪刀-石头-布-斯波克-蜥蜴人-剪刀-石头-布-斯波克-蜥蜴人-......”

已知小 A和小 B 一共进行 NN 次猜拳。每一次赢的人得 11 分，输的得 00 分；平局两人都得 00 分。现请你统计 NN 次猜拳结束之后两人的得分。

输入输出格式
输入格式：
第一行包含三个整数：N,N_A,N_BN,N 
A
​	 ,N 
B
​	 ,分别表示共进行 NN 次猜拳、小 A出拳的周期长度，小 B 出拳的周期长度。数与数之间以一个空格分隔。

第二行包含 N_AN 
A
​	  个整数,表示小 A出拳的规律,第三行包含 N_BN 
B
​	  个整数,表示小 B 出拳的规律。其中，00 表示“剪刀”，11 表示“石头”，22 表示“布”，33 表示“蜥蜴人”，4 4表示“斯波克”。数与数之间以一个空格分隔。

输出格式：
输出一行，包含两个整数，以一个空格分隔，分别表示小 A、小 B的得分。

输入输出样例
输入样例#1： 
10 5 6
0 1 2 3 4
0 3 4 2 1 0
输出样例#1： 
6 2
输入样例#2： 
9 5 5
0 1 2 3 4
1 0 3 2 4
输出样例#2： 
4 4
说明
对于100\%100%的数据，0 < N \leq 200, 0 < N_A \leq 200, 0 < N_B \leq 2000<N≤200,0<N 
A
​	 ≤200,0<N 
B
​	 ≤200 。


思路:

    想到了使用 % 进行周期循环，因为数据范围并不是很大，刚开始还在考虑要不要使用优化来着，就是当 N
    大于 Na 和 Nb 的最小公倍数的，可以简化掉当 N 是 Na 和 Nb 最小公倍数的很多倍的时候的很多重复计算，
    只需要遍历一次 (times > 0 ? mcm : n) 次就可以通过计算得出结果


*/
#include <iostream>
using namespace std;

int fa[200], fb[200];
int vs[5][5] = {{0, 0, 1, 1, 0}, 
                {1, 0, 0, 1, 0}, 
                {0, 1, 0, 0, 1},
                {0, 0, 1, 0, 1}, 
                {1, 1, 0, 0, 0}};

int maxCommonDivisor(int m, int n) {  
    if (m < n) {     // 保证被除数大于除数
        int temp = m;  
        m = n;  
        n = temp;  
    }  
    while (m % n != 0) {  // 在余数不能为0时,进行循环  
        int temp = m % n;  
        m = n;  
        n = temp;  
    }  
    return n;    // 返回最大公约数  
}  
int minCommonMultiple(int m, int n) {  
    return m * n / maxCommonDivisor(m, n);  
}  

int main() {
    int n, a, b;
    cin >> n >> a >> b;
    
    for (int i = 0; i < a; i++) {
        cin >> fa[i];
    }
    for (int i = 0; i < b; i++) {
        cin >> fb[i];
    }
    int wa = 0, wb = 0;
    int enda = 0, endb = 0;
    int mcm = minCommonMultiple(a, b);
    int times = n / mcm;
    int ends = n % mcm;
    // cout << mcm << ' ' << times << ' ' << ends << endl;
    for (int i = 0; i < ((times > 0) ? mcm : n); i++) {
        wa += vs[fa[i % a]][fb[i % b]];
        wb += vs[fb[i % b]][fa[i % a]];
        if (i == ends - 1) {
            enda = wa;
            endb = wb;
        }
    }
    // cout << wa << ' ' << wb << ' ' << enda << ' ' << endb << endl;
    wa = wa * times + enda;
    wb = wb * times + endb;
    cout << wa << ' ' << wb;
    return 0;
}