## 高精度乘除法
 
### 仅限于被乘除的数比较小的情况

#### 初始化

1. `k[N*4]`：   乘积，每个乘数小于 `10 ^ 4` 所以使用 `N * 4` 作为长度，默认值为 `k = {0, 1, 0, 0, 0, ...} => k[1] = 1`
2. `lk`：       乘积的长度，默认值为 `kl = 1`
3. `ans[N*4]`： 商
4. `la`：       商的长度，默认值为 `la = 1`
5. `ans0[N*4]`：期望的答案的值，例如最大值，最小值 
6. `la0`：      

```cpp

int n, k[N*4], lk = 1, ans[N*4], la = 1, ans0[N*4], la0 = 1;

```

### 高精度除法

1. `w` 保存余数，初始化为 `w = 0`，并使用 `* 10 + k[i]` ，相当于从被除数对应商的后一位借位
2. 当 `w` 的值大于 `x` 的时候，`ans[i]` 才不为 `0`，模拟了除法的过程
3. 使用 `al` 保存 `ans` 的实际长度，使用 `flag & ans[i] != 0` 即不小于 `x` 的第一的位置，将 `flag = 0` 值为零

#### core


```cpp

void h_div(int x) {
    int w = 0;
    for (int i = lk; i >= 0; i--) {
        w = w * 10 + k[i];
        ans[i] = w / x;
        w %= x;
    }
}

// 记录 ans 的长度
void h_div(int x) {
    bool flag = true;
    int w = 0;
    for (int i = lk; i >= 0; i++) {
        w = w * 10 + k[i];
        ans[i] = w /x;
        w %= x;
        if (flag && ans[i] != 0) {
            al = i;
            flag = false;
        }
    }
}

```

## 高精度乘法

1. 使用 `int k[N], lk = 1;` 和` k[1] = 1;` 初始化长度为所有数的乘积对应的十进制表示时的长度，`lk` 为他的长度，因为是要乘上其他的数，所以默认值为 `1` 
2. 让所有的位都乘上 `x` 的值，这样就相当于从其中一个乘数从尾到头将每一位乘上了另一个数，乘法中是将所有的进行相加，从而得出结果
3. 将 `lk + 4` 即加上 `x` 最大值的十进制位数，防止越界，然后开始模拟乘法
> - 乘法的逐位乘积是乘上 `k[i] * (10 ^ i)`，其实相当于向左偏移了他对应的下标位
> - 根据这种原理，每一位只需要保留他的 `k[i] % 10` 个位数作为该位数组，将 `k[i] / 10` 的值加到前一位上去，即 `k[i + 1]`


#### core

```cpp

void h_mul(int x) {
    for (int i = 1; i <= lk; i++) k[i] *= x;
    k += 4;
    for (int i = 1; i <= lk; i++) {
        k[i + 1] += k[i] / 10;
        k[i] %= 10;
    }
    whle (k[lk] == 0) lk--;
}

```
